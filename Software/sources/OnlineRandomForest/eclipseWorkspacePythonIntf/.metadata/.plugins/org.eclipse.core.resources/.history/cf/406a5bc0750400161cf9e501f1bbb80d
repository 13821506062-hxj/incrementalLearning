#include "Python.h"
#include "arrayobject.h"
#include <vector>
#include <iostream>
#include <iterator>
#include <algorithm>
using namespace std;
#include <limits>
struct sortItem {
    double value;
    unsigned int index;
};

struct by_number {
    bool operator()(sortItem const &left, sortItem const &right) {
        return left.value < right.value;
    }
};

void nArgMin(const int &n, const double* values, int* indices, const int &numValues){
	for (unsigned int i=0; i<n; i++){
		double minValue = std::numeric_limits<double>::max();
		for (unsigned int j=0; j<numValues; j++){
			if (values[j] < minValue){
				bool alreadyUsed = false;
				for (unsigned int k=0; k<i; k++){
					if (indices[k]==j)
						alreadyUsed = true;
				}
				if (!alreadyUsed)
					indices[i] = j;
					minValue = values[j];
					cout << minValue << " " << indices[i] << endl;
			}
		}
	}
}

//void nArgMin(const int &n, const double* values, int* indices, const int &numValues){
//	double minValues[n];
//	std::fill_n(minValues, n, std::numeric_limits<double>::max());
//	for (unsigned int i=0; i<numValues; i++){
//		for (unsigned int j=0; j<n; j++){
//			if (values[i] < minValues[j]){
//				for (unsigned int k=j+1; k<n; k++){
//					if (values[i] >= minValues[k]){
//						minValues[k-1] = values[i];
//						indices[k-1] = i;
//						cout << "one " << k-1 << endl;
//						break;
//					}
//					if (k==n-1){
//						minValues[k] = values[i];
//						indices[k] = i;
//						cout << "two " << k << endl;
//					}
//				}
//				break;
//			}
//		}
//		cout << i << " " << values[i] << endl;
//		for (unsigned int j=0; j<n; j++){
//			cout << minValues[j] << " ";
//		}
//		cout << " minValues " << endl;
//		for (unsigned int j=0; j<n; j++){
//			cout << indices[j] << " ";
//		}
//		cout << " indices" << endl;
//
//	}
//}

void nArgMinN(const int &n, const double* values, int* indices, const int &nRows, const int &numValues){
	for (unsigned int i=0; i<nRows; i++)
	{
		nArgMin(n, &values[i*numValues], &indices[i*n], numValues);
	}
}


void argSort(const double* values, int* indices, const int &numValues){
	std::vector<sortItem> items(numValues);
	for (unsigned int i=0; i<numValues; i++)
	{
		struct sortItem a = {values[i], i};
		items[i] = a;
	}

	std::sort(items.begin(), items.end(), by_number());
	for (unsigned int i=0; i<numValues; i++)
	{
		indices[i] = items[i].index;
	}
}

void quickSort(double arr[], int indices[], int left, int right) {
	int i = left, j = right;
	int tmp, tmpIdx;
	double pivot = arr[(left + right) / 2];

	/* partition */
	while (i <= j) {
		while (arr[i] < pivot)
			  i++;
		while (arr[j] > pivot)
			  j--;
		if (i <= j) {
//			  std::swap(arr[i],arr[j]);
//			  std::swap(indices[i],indices[j]);

			  tmp = arr[i];
			  tmpIdx = indices[i];
			  arr[i] = arr[j];
			  indices[i] = indices[j];
			  arr[j] = tmp;
			  indices[j] = tmpIdx;
			  i++;
			  j--;
		}
	};

	/* recursion */
	if (left < j)
		quickSort(arr, indices, left, j);
	if (i < right)
		quickSort(arr, indices, i, right);
}

void argSort2(const double* values, int* indices, const int &numValues){
	double values2[numValues];
	int indices2[numValues];
	for (unsigned int i=0; i<numValues; i++){
		indices2[i] = i;
		values2[i] = values[i];
	}
	quickSort(values2, indices2, 0, numValues-1);
	for (unsigned int i=0; i<numValues; i++){
		indices[i] = indices2[i];
	}
}

void argSortN(const double* values, int* indices, const int &numRows, const int &numValues){
	for (unsigned int i=0; i<numRows; i++)
	{
		argSort2(&values[i*numValues], &indices[i*numValues], numValues);
	}
}


double get1To1Distance(std::vector<double> sample, std::vector<double> sample2)
{
	double sum=0;
	for (unsigned int i=0; i<sample.size(); i++)
	{
		double diff = sample[i]-sample2[i];
		sum += diff*diff;
	}
	return sum;
}


double get1To1Distance2(const double* sample, const double *sample2, const int &numFeatures)
{
	double sum=0;
	for (unsigned int i=0; i<numFeatures; i++)
	{
		double diff = sample[i]-sample2[i];
		sum += diff*diff;
	}
	return sum;
}

std::vector<double> get1ToNDistancesIntern(std::vector<double> sample, std::vector<std::vector<double> > samples){
	vector<double> results(samples.size());
	for (unsigned int i=0; i<samples.size(); i++){
		results[i] = get1To1Distance(sample, samples[i]);
	}
	return results;
}

void get1ToNDistancesIntern2(const double *sample, const double *samples, double *distances, const int &numSamples, const int &numFeatures){
	for (unsigned int i=0; i<numSamples; i++){
		distances[i] = get1To1Distance2(sample, &samples[i*numFeatures], numFeatures);
	}
}

std::vector<std::vector<double> > getNToNDistancesIntern(std::vector<std::vector<double> > samples, std::vector<std::vector<double> > samples2){
	vector<vector<double> > results(samples.size());
	for (unsigned int i=0; i<samples.size(); i++){
		results[i] = get1ToNDistancesIntern(samples[i], samples2);
	}
	return results;
}

void getNToNDistancesIntern2(const double *samples, const double *samples2, double *distances, const int &numSamples, const int &numSamples2, const int &numFeatures){
	for (unsigned int i=0; i<numSamples; i++){
		get1ToNDistancesIntern2(&samples[i*numFeatures], samples2, &distances[numSamples2*i], numSamples2, numFeatures);
	}
}

void getNToNDistances(const double* carrSampleData, const double* carrSampleData2, double* carrDistances, const int& sampleDataRows, const int& sampleData2Rows, const int& numFeatures){
	std::vector<std::vector<double> > samples(sampleDataRows);
	for (int i=0; i< sampleDataRows; i++){
		const double* sampledata = &carrSampleData[numFeatures * i];
		std::vector<double> v(sampledata, sampledata + numFeatures);
		samples[i] = v;
	}
	std::vector<std::vector<double> > samples2(sampleData2Rows);
	for (int i=0; i< sampleData2Rows; i++){
		const double* sampledata = &carrSampleData2[numFeatures * i];
		std::vector<double> v(sampledata, sampledata + numFeatures);
		samples2[i] = v;
	}
	std::vector<std::vector<double> > result = getNToNDistancesIntern(samples, samples2);
	for (int i=0; i< sampleDataRows; i++){
		for (int j=0; j< sampleData2Rows; j++){
			carrDistances[i*sampleData2Rows+j] = result[i][j];
		}
	}
}


void get1ToNDistances(const double* carrSampleData, const double* carrSampleData2, double* carrDistances, const int& sampleData2Rows, const int& numFeatures){
	std::vector<double> sample(carrSampleData, carrSampleData + numFeatures);
	std::vector<std::vector<double> > samples2(sampleData2Rows);
	for (int i=0; i< sampleData2Rows; i++){
		const double* sampledata = &carrSampleData2[numFeatures * i];
		std::vector<double> v(sampledata, sampledata + numFeatures);
		samples2[i] = v;
	}
	std::vector<double> result = get1ToNDistancesIntern(sample, samples2);

	for (int i=0; i< sampleData2Rows; i++){
		carrDistances[i] = result[i];
	}
}


void getNToNDistances2(const double* carrSampleData, const double* carrSampleData2, double* carrDistances, const int& sampleDataRows, const int& sampleData2Rows, const int& numFeatures){
	getNToNDistancesIntern2(carrSampleData, carrSampleData2, carrDistances, sampleDataRows, sampleData2Rows, numFeatures);
}

void get1ToNDistances2(const double* carrSampleData, const double* carrSampleData2, double* carrDistances, const int& sampleData2Rows, const int& numFeatures){
	get1ToNDistancesIntern2(carrSampleData, carrSampleData2, carrDistances, sampleData2Rows, numFeatures);
}


static PyObject *py_getNToNDistances(PyObject *self, PyObject *args) {
	PyObject *sampleData;
	PyObject *sampleData2;
	if (!PyArg_ParseTuple(args, "OO", &sampleData, &sampleData2))
		return NULL;

	//create c-arrays:
	PyArrayObject *matSampleData;
	matSampleData = (PyArrayObject *) PyArray_ContiguousFromObject(sampleData,
			PyArray_DOUBLE, 1, 2);
	double *carrSampleData = (double*) (matSampleData->data);
	npy_intp sampleDataRows = matSampleData->dimensions[0];
	npy_intp sampleDataCols = matSampleData->dimensions[1];

	if (matSampleData->nd == 1) {
		sampleDataCols = sampleDataRows;
		sampleDataRows = 1;
	}
	PyArrayObject *matSampleData2;
	matSampleData2 = (PyArrayObject *) PyArray_ContiguousFromObject(sampleData2,
			PyArray_DOUBLE, 1, 2);
	double *carrSampleData2 = (double*) (matSampleData2->data);
	npy_intp sampleData2Rows = matSampleData2->dimensions[0];

	if (matSampleData2->nd == 1) {
		sampleData2Rows = 1;
	}
	npy_intp Dims[2];
	Dims[0]= sampleDataRows;
	Dims[1] = sampleData2Rows;

	PyArrayObject *distances = (PyArrayObject *) PyArray_SimpleNew(2,
			Dims, PyArray_DOUBLE);
	PyArrayObject *matDistances;
	matDistances = (PyArrayObject *) PyArray_ContiguousFromObject(
			(PyObject* )distances, PyArray_DOUBLE, 1, 2);

	double *carrDistances = (double*) (matDistances->data);

	getNToNDistances2(carrSampleData, carrSampleData2, carrDistances, sampleDataRows, sampleData2Rows, sampleDataCols);

	Py_DECREF(matSampleData);
	Py_DECREF(matSampleData2);
	Py_DECREF(matDistances);
	return Py_BuildValue("O", matDistances);
}

PyDoc_STRVAR(py_getNToNDistances__doc__,
		"name, data 2D-arr. Returns label result matrix");




static PyObject *py_get1ToNDistances(PyObject *self, PyObject *args) {
	PyObject *sampleData;
	PyObject *samplesData;
	if (!PyArg_ParseTuple(args, "OO", &sampleData, &samplesData))
		return NULL;

	//create c-arrays:
	PyArrayObject *matSampleData;
	matSampleData = (PyArrayObject *) PyArray_ContiguousFromObject(sampleData,
			PyArray_DOUBLE, 1, 1);
	double *carrSampleData = (double*) (matSampleData->data);
	npy_intp sampleDataRows = matSampleData->dimensions[0];
	npy_intp sampleDataCols = matSampleData->dimensions[1];

	if (matSampleData->nd == 1) {
		sampleDataCols = sampleDataRows;
		sampleDataRows = 1;
	}

	PyArrayObject *matSamplesData;
	matSamplesData = (PyArrayObject *) PyArray_ContiguousFromObject(samplesData,
			PyArray_DOUBLE, 1, 2);
	double *carrSamplesData = (double*) (matSamplesData->data);
	npy_intp samplesDataRows = matSamplesData->dimensions[0];

	if (matSamplesData->nd == 1) {
		samplesDataRows = 1;
	}

	PyArrayObject *distances = (PyArrayObject *) PyArray_SimpleNew(1,
			&samplesDataRows, PyArray_DOUBLE);
	PyArrayObject *matDistances;
	matDistances = (PyArrayObject *) PyArray_ContiguousFromObject(
			(PyObject* )distances, PyArray_DOUBLE, 1, 1);
	double *carrDistances = (double*) (matDistances->data);
	get1ToNDistances2(carrSampleData, carrSamplesData, carrDistances, samplesDataRows, sampleDataCols);
	Py_DECREF(matSampleData);
	return Py_BuildValue("O", matDistances);
}

PyDoc_STRVAR(py_get1ToNDistances__doc__,
		"name, data 2D-arr. Returns label result matrix");


static PyObject *py_argSort(PyObject *self, PyObject *args) {
	PyObject *values;
	if (!PyArg_ParseTuple(args, "O", &values))
		return NULL;

	//create c-arrays:
	PyArrayObject *matValues;
	matValues = (PyArrayObject *) PyArray_ContiguousFromObject(values,
			PyArray_DOUBLE, 1, 1);
	if ((NULL == matValues)
			|| (((PyArrayObject *) values)->descr->type_num != NPY_DOUBLE)) {
		printf(
				"1Error: data must be a 2-D double mat, each row is one datasample\n");
		return NULL;
	}
	double *carrValues = (double*) (matValues->data);
	npy_intp numValues = matValues->dimensions[0];

	PyArrayObject *indices = (PyArrayObject *) PyArray_SimpleNew(1,
			&numValues, PyArray_INT);
	PyArrayObject *matIndices;
	matIndices = (PyArrayObject *) PyArray_ContiguousFromObject(
			(PyObject* )indices, PyArray_INT, 1, 1);
	if (NULL == matIndices) {
		printf("Error: distances must be a 1-D double mat\n");
		return NULL;
	}
	int *carrIndices = (int*) (matIndices->data);
	int carrNumValues = matIndices->dimensions[0];

	if (numValues != carrNumValues) {
		printf(
				"Error: data's number of rows must equal the number of labels!\n");
		return NULL;
	}
	argSort(carrValues, carrIndices, numValues);
	Py_DECREF(matValues);
	return Py_BuildValue("O", matIndices);
}

static PyObject *py_argSortN(PyObject *self, PyObject *args) {
	PyObject *values;
	if (!PyArg_ParseTuple(args, "O", &values))
		return NULL;

	//create c-arrays:
	PyArrayObject *matValues;
	matValues = (PyArrayObject *) PyArray_ContiguousFromObject(values,
			PyArray_DOUBLE, 1, 2);
	double *carrValues = (double*) (matValues->data);
	npy_intp numRows = matValues->dimensions[0];
	npy_intp numValues = matValues->dimensions[1];

	if (matValues->nd == 1) {
		numValues = numRows;
		numRows = 1;
	}
	npy_intp Dims[2];
	Dims[0]= numRows;
	Dims[1] = numValues;

	PyArrayObject *indices = (PyArrayObject *) PyArray_SimpleNew(2,
			Dims, PyArray_INT);
	PyArrayObject *matIndices;
	matIndices = (PyArrayObject *) PyArray_ContiguousFromObject(
			(PyObject* )indices, PyArray_INT, 1, 2);
	int *carrIndices = (int*) (matIndices->data);
	argSortN(carrValues, carrIndices, numRows, numValues);
	Py_DECREF(matValues);
	Py_DECREF(matIndices);
	return Py_BuildValue("O", matIndices);
}

PyDoc_STRVAR(py_argSort__doc__,
		"name, data 2D-arr. Returns label result matrix");


static PyObject *py_nArgMin(PyObject *self, PyObject *args) {
	PyObject *values;
	int n;
	if (!PyArg_ParseTuple(args, "iO", &n, &values))
		return NULL;

	//create c-arrays:
	PyArrayObject *matValues;
	matValues = (PyArrayObject *) PyArray_ContiguousFromObject(values,
			PyArray_DOUBLE, 1, 2);
	double *carrValues = (double*) (matValues->data);
	npy_intp numRows = matValues->dimensions[0];
	npy_intp numValues = matValues->dimensions[1];

	if (matValues->nd == 1) {
		numValues = numRows;
		numRows = 1;
	}
	npy_intp Dims[2];
	Dims[0]= numRows;
	Dims[1] = n;

	PyArrayObject *indices = (PyArrayObject *) PyArray_SimpleNew(2,
			Dims, PyArray_INT);
	PyArrayObject *matIndices;
	matIndices = (PyArrayObject *) PyArray_ContiguousFromObject(
			(PyObject* )indices, PyArray_INT, 1, 2);
	int *carrIndices = (int*) (matIndices->data);
	nArgMinN(n, carrValues, carrIndices, numRows, numValues);
	Py_DECREF(matValues);
	Py_DECREF(matIndices);
	return Py_BuildValue("O", matIndices);
}

PyDoc_STRVAR(py_nArgMin__doc__,
		"name, data 2D-arr. Returns label result matrix");

/* The module doc string */
PyDoc_STRVAR(ORF__doc__, "Mandelbrot point evalutation kernel");



/* A list of all the methods defined by this module. */
/* "iterate_point" is the name seen inside of Python */
/* "py_iterate_point" is the name of the C function handling the Python call */
/* "METH_VARGS" tells Python how to call the handler */
/* The {NULL, NULL} entry indicates the end of the method definitions */
static PyMethodDef NN_methods[] = { {"getNToNDistances", py_getNToNDistances, METH_VARARGS, py_getNToNDistances__doc__},
		{"get1ToNDistances", py_get1ToNDistances, METH_VARARGS, py_getNToNDistances__doc__},
		{"argSort", py_argSortN, METH_VARARGS, py_argSort__doc__},
		{"nArgMin", py_nArgMin, METH_VARARGS, py_nArgMin__doc__},

		{ NULL, NULL } /* sentinel */
};

/* When Python imports a C module named 'X' it loads the module */
/* then looks for a method named "init"+X and calls it.  Hence */
/* for the module "mandelbrot" the initialization function is */
/* "initmandelbrot".  The PyMODINIT_FUNC helps with portability */
/* across operating systems and between C and C++ compilers */
PyMODINIT_FUNC initlibNNPythonIntf(void) {
	import_array()
		/* There have been several InitModule functions over time */
	PyObject* myclass = Py_InitModule3("libNNPythonIntf", NN_methods,
			ORF__doc__);

}
