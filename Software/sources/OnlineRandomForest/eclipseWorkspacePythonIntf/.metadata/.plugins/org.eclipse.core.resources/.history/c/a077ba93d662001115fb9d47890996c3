'''
Created on Feb 29, 2012

@author: jqueisse
'''

import numpy
import matplotlib
import matplotlib.pyplot as plt

import numpy
from svmutil import *


def getRotationMatrix(rotation):

    sinrot = numpy.sin(rotation)
    cosrot = numpy.cos(rotation)
    return numpy.array([[cosrot, -sinrot],[sinrot, cosrot]])

def createNormDistData(samples, mean=(0,0), var=(1,1), rotation=0):
    cov =   numpy.array([[var[0],-0],
             [-0,var[1]]])
    if not rotation==0:
        points=numpy.random.multivariate_normal((0,0),cov,(samples))
        return numpy.dot(getRotationMatrix(rotation),points.T).T + mean
    else:
        return  numpy.random.multivariate_normal(mean,cov,(samples))



if __name__ == '__main__':


    a1 = createNormDistData(3000, mean=(0,0),var=(30,1), rotation = numpy.pi/2)
    b1 = createNormDistData(3000, mean=(10,10), var=(10,1), rotation = numpy.pi/2)
    a2 = createNormDistData(3000, mean=(20,10),var=(10,1), rotation = numpy.pi/2)
    b2 = createNormDistData(3000, mean=(30,0), var=(30,1), rotation = numpy.pi/2)

    classc =  createNormDistData(5000, mean=(15,-7), var=(90,2), rotation=0)
    classc_Z = numpy.sin((numpy.pi/30)*classc[:,0] - numpy.pi/2)*5
    print classc_Z.shape, classc.shape
    classc = numpy.vstack([classc.T, classc_Z]).T
    print classc.shape


    classa = numpy.vstack([a1,a2])
    classb = numpy.vstack([b1,b2])


    fig = plt.figure()
    ax = fig.add_subplot(111, aspect='equal')
    ax.hold(True)
    ax.plot(classa[:,0], classa[:,1], '1b',classb[:,0], classb[:,1], '2m',classc[:,0], classc[:,1], '3g')
    ax.set_title('Data Input')

    plt.show()





    result=numpy.zeros([classa.shape[0]])
    data=numpy.vstack([classa,classb])
    result=numpy.hstack([result, numpy.ones([classb.shape[0]])])
    resultfull=numpy.hstack([result, numpy.ones([classc.shape[0]])])

    print data.shape, numpy.zeros((data.shape[0])).shape
    data3d = numpy.hstack([data, numpy.zeros((data.shape[0])).T])
    datafull=numpy.vstack([data3d,classc])

    #train svm:
    px = svm.svm_problem(result, data.tolist())
    # the kernel function i have selected is RBF (radial basis function)
    pm = svm.svm_parameter()
    pm.kernel_type=svm.RBF
    pm.probability=True

    v = svm_train(px, pm)





